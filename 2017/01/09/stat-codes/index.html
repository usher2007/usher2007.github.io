<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  
  <title>这些年，你写了多少行代码 | 一根笨茄子</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  
    <meta name="author" content="Yubo Guo">
  
  
    <meta name="description" content="又到了辞旧迎新的时候。最近已经被各路大拿的总结砸的晕头转向了，心想人家的2016为何能做那么多事那么精彩呢？不过还好，我有“幸存者偏差”这一法宝安慰自己……  
言归正传，前一阵突然想到，自己进入项目组已经差不多两年了，不如用最朴素的方式——统计代码行数——来总结下吧。  
虽然目前已经有各种各样的工具可以做这件事情，不过自己写一个应该也很快，说不定还有其他发现呢。">
  
  <meta name="description" content="又到了辞旧迎新的时候。最近已经被各路大拿的总结砸的晕头转向了，心想人家的2016为何能做那么多事那么精彩呢？不过还好，我有“幸存者偏差”这一法宝安慰自己……  
言归正传，前一阵突然想到，自己进入项目组已经差不多两年了，不如用最朴素的方式——统计代码行数——来总结下吧。  
虽然目前已经有各种各样的工具可以做这件事情，不过自己写一个应该也很快，说不定还有其他发现呢。">
<meta property="og:type" content="article">
<meta property="og:title" content="这些年，你写了多少行代码">
<meta property="og:url" content="http://blog.guoyb.com/2017/01/09/stat-codes/index.html">
<meta property="og:site_name" content="一根笨茄子">
<meta property="og:description" content="又到了辞旧迎新的时候。最近已经被各路大拿的总结砸的晕头转向了，心想人家的2016为何能做那么多事那么精彩呢？不过还好，我有“幸存者偏差”这一法宝安慰自己……  
言归正传，前一阵突然想到，自己进入项目组已经差不多两年了，不如用最朴素的方式——统计代码行数——来总结下吧。  
虽然目前已经有各种各样的工具可以做这件事情，不过自己写一个应该也很快，说不定还有其他发现呢。">
<meta property="og:image" content="http://7d9lwm.com1.z0.glb.clouddn.com/newqr.jpg">
<meta property="og:updated_time" content="2017-11-03T03:48:09.803Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="这些年，你写了多少行代码">
<meta name="twitter:description" content="又到了辞旧迎新的时候。最近已经被各路大拿的总结砸的晕头转向了，心想人家的2016为何能做那么多事那么精彩呢？不过还好，我有“幸存者偏差”这一法宝安慰自己……  
言归正传，前一阵突然想到，自己进入项目组已经差不多两年了，不如用最朴素的方式——统计代码行数——来总结下吧。  
虽然目前已经有各种各样的工具可以做这件事情，不过自己写一个应该也很快，说不定还有其他发现呢。">
<meta name="twitter:image" content="http://7d9lwm.com1.z0.glb.clouddn.com/newqr.jpg">
  
  
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  <!--[if lt IE 9]><script src="//cdn.bootcss.com/html5shiv/3.7.0/html5shiv.min.js"></script><![endif]-->
  
  
<script type="text/javascript">
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?996ee0fca2512b4c29f37f60cf6387ca";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
  (adsbygoogle = window.adsbygoogle || []).push({
    google_ad_client: "ca-pub-6897127630340076",
    enable_page_level_ads: true
  });
</script>

</head>
<body>
  <div class="wrapper">
    <header id="header">
  <div class="title">
    <h1><a href="/">一根笨茄子</a></h1>
    <p><a href="/"></a></p>
  </div>
  <nav class="nav">
    <ul>
      
        <li><a href="/archives">归档</a></li>
      
        <li><a href="/about">关于我</a></li>
      
      
    </ul>
    <div class="clearfix"></div>
  </nav>
  <div class="clearfix"></div>
</header>
    <div class="content"><article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2017/01/09/stat-codes/">
  <time datetime="2017-01-09T00:13:44.000Z">
    2017-01-09
  </time>
</a>
    
    
  
    <h1 class="title">这些年，你写了多少行代码</h1>
  

  </header>
  
  <div class="entry">
    
      <hr>
<p>又到了辞旧迎新的时候。最近已经被各路大拿的总结砸的晕头转向了，心想人家的2016为何能做那么多事那么精彩呢？不过还好，我有“幸存者偏差”这一法宝安慰自己……  </p>
<p>言归正传，前一阵突然想到，自己进入项目组已经差不多两年了，不如用最朴素的方式——统计代码行数——来总结下吧。  </p>
<p>虽然目前已经有各种各样的工具可以做这件事情，不过自己写一个应该也很快，说不定还有其他发现呢。<br><a id="more"></a>  </p>
<h2 id="初版"><a href="#初版" class="headerlink" title="初版"></a>初版</h2><hr>
<p>统计“现存”代码行数，无非就是找到所有需要统计的文件，svn/git blame，然后一行一行的分析计数即可。所以第一版很快就写出来了：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ignore_paths = [<span class="string">'ignore/path1'</span>, <span class="string">'ignore/path2'</span>]</span><br><span class="line">code_stats = defaultdict(int)</span><br><span class="line"><span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(<span class="string">'/path/to/codes/root/'</span>):</span><br><span class="line">	ignore = <span class="keyword">False</span></span><br><span class="line">	<span class="keyword">for</span> ig_path <span class="keyword">in</span> ignore_paths:</span><br><span class="line">		<span class="keyword">if</span> ig_path <span class="keyword">in</span> root:</span><br><span class="line">			ignore = <span class="keyword">True</span></span><br><span class="line">	<span class="keyword">if</span> ignore:</span><br><span class="line">		<span class="keyword">continue</span></span><br><span class="line">	<span class="keyword">for</span> fname <span class="keyword">in</span> files:</span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">not</span> fname.endswith(<span class="string">'.py'</span>):</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		abs_file_path = join(root, fname)</span><br><span class="line">		stat_file(abs_file_path)</span><br><span class="line"><span class="keyword">print</span> code_stats</span><br></pre></td></tr></table></figure>  </p>
<p>其中，ignore_paths中存储的是一些机器生成代码的目录，我们将其排除在外，可以节省一定的时间。  </p>
<p>stat_file函数具体处理统计每一个文件：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">cmd_prefix = <span class="string">'svn blame '</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stat_file</span><span class="params">(fname)</span>:</span></span><br><span class="line">	cmd = cmd_prefix + fname</span><br><span class="line">	args = shlex.split(cmd)</span><br><span class="line">	<span class="keyword">with</span> open(<span class="string">'blame.py'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">		subprocess.call(args, stdout=f)</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">with</span> open(<span class="string">'blame.py'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">		<span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">			args = line.split()</span><br><span class="line">			<span class="keyword">if</span> len(args) &gt;= <span class="number">2</span>:</span><br><span class="line">				author = args[<span class="number">1</span>]</span><br><span class="line">				<span class="keyword">if</span> <span class="string">'@'</span> <span class="keyword">in</span> author:</span><br><span class="line">					author = author.split(<span class="string">'@'</span>)[<span class="number">0</span>]</span><br><span class="line">				code_stats[author] += <span class="number">1</span></span><br></pre></td></tr></table></figure>  </p>
<p>这里我们利用了svn blame得到的结果格式，获得每一行代码的当前作者信息。  </p>
<p>整个程序很简单明了，但是运行起来，太太太太慢了……首先所有文件的统计技术都是串行的，其次svn blame的运行本来就很耗时。但是先不管这么多，运行完看看结果先……  </p>
<p>于是我去做其他事情了。不知过了多久，终于统计出结果了~结果先暂时保密……  </p>
<h2 id="改进版"><a href="#改进版" class="headerlink" title="改进版"></a>改进版</h2><hr>
<p>接下来就开始考虑改进执行效率。对于这种有阻塞IO、各个任务之间又基本互不干涉的情况，当然优先考虑多进程/多线程的方式了。不过究竟用多进程还是多线程呢？这里有个神器multiprocessing.dummy。multiprocessing大家应该都熟，是Python中的多进程模块，而这个dummy呢，则是实现了multiprocessing的所有接口、模块，不过内部是按照多线程的方式实现的。  </p>
<p>这样的话，我们可以先按照多进程multiprocessing的方式写程序，之后直接将multiprocessing替换成dummy，就可以得到一个多线程版本，是不是炒鸡方便？  </p>
<p>多线程/多进程程序，首先要对所有的任务进行划分，我们这里策略比较直接：将所有文件按照进程数P_NUM切分成P_NUM份。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">P_NUM = <span class="number">8</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stat_files</span><span class="params">()</span>:</span></span><br><span class="line">	all_files = []</span><br><span class="line">	<span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(<span class="string">'/path/to/codes/root/'</span>):</span><br><span class="line">		ignore = <span class="keyword">False</span></span><br><span class="line">		<span class="keyword">for</span> ig_path <span class="keyword">in</span> ignore_paths:</span><br><span class="line">			<span class="keyword">if</span> ig_path <span class="keyword">in</span> root:</span><br><span class="line">				ignore = <span class="keyword">True</span></span><br><span class="line">		<span class="keyword">if</span> ignore:</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		<span class="keyword">for</span> fname <span class="keyword">in</span> files:</span><br><span class="line">			<span class="keyword">if</span> <span class="keyword">not</span> fname.endswith(<span class="string">'.py'</span>):</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			abs_file_path = join(root, fname)</span><br><span class="line">			all_files.append(abs_file_path)</span><br><span class="line">	</span><br><span class="line">	file_sections = []</span><br><span class="line">	file_total_nums = len(all_files)</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> xrange(P_NUM):</span><br><span class="line">		start = i * file_total_nums / P_NUM</span><br><span class="line">		stop = start + file_total_nums / P_NUM</span><br><span class="line">		<span class="keyword">if</span> i == P_NUM - <span class="number">1</span>:</span><br><span class="line">			stop = <span class="number">-1</span></span><br><span class="line">		file_sections.append(all_files[start : stop])</span><br></pre></td></tr></table></figure>  </p>
<p>之后，我们使用Multiprocessing.Queue来存贮各个子进程的执行结果，最后进行汇总。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stat_files</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="comment">###above###</span></span><br><span class="line">	all_files = []</span><br><span class="line">	res_queue = Queue()</span><br><span class="line">	processes = []</span><br><span class="line">	<span class="keyword">for</span> section <span class="keyword">in</span> file_sections:</span><br><span class="line">		p = Process(target=stat_file, args=(section, res_queue))</span><br><span class="line">		p.start()</span><br><span class="line">		processes.append(p)</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> p <span class="keyword">in</span> processes:</span><br><span class="line">		p.join()</span><br><span class="line">	</span><br><span class="line">	total_stats = defaultdict(int)</span><br><span class="line">	<span class="keyword">while</span> <span class="keyword">not</span> res_queue.empty():</span><br><span class="line">		stat = res_queue.get()</span><br><span class="line">		<span class="keyword">for</span> author, cnt <span class="keyword">in</span> stat.iteritems():</span><br><span class="line">			total_stats[author] += cnt</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">print</span> total_stats</span><br></pre></td></tr></table></figure>  </p>
<p>每一个进程上的统计任务stat_file，除了需哟将结果放入Queue中之外，没有其他区别：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">cmd_prefix = <span class="string">'svn blame '</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stat_file</span><span class="params">(fnames, res_queue)</span>:</span></span><br><span class="line">	code_stats = defaultdict(int)</span><br><span class="line">	<span class="keyword">for</span> fname <span class="keyword">in</span> fnames:</span><br><span class="line">		<span class="keyword">print</span> <span class="string">'processing '</span>, fname</span><br><span class="line">		cmd = cmd_prefix + fname</span><br><span class="line">		args = shlex.split(cmd)</span><br><span class="line">		blame_file_name = <span class="string">'blame_'</span> + os.path.basename(fname) + str(random.randint(<span class="number">0</span>, <span class="number">100</span>)) + <span class="string">'.py'</span></span><br><span class="line">		<span class="keyword">with</span> open(blame_file_name, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">			subprocess.call(args, stdout=f)</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">with</span> open(blame_file_name, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">			<span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">				args = line.split()</span><br><span class="line">				<span class="keyword">if</span> len(args) &gt;= <span class="number">2</span>:</span><br><span class="line">					author = args[<span class="number">1</span>]</span><br><span class="line">					<span class="keyword">if</span> <span class="string">'@'</span> <span class="keyword">in</span> author:</span><br><span class="line">						author = author.split(<span class="string">'@'</span>)[<span class="number">0</span>]</span><br><span class="line">					code_stats[author] += <span class="number">1</span></span><br><span class="line">		os.remove(blame_file_name)</span><br><span class="line"></span><br><span class="line">	res_queue.put(code_stats)</span><br></pre></td></tr></table></figure>  </p>
<p>那么，通过切换如下两种import语句，即可切换多进程/多线程：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Queue</span><br><span class="line"><span class="comment">#from multiprocessing.dummy import Process, Queue</span></span><br></pre></td></tr></table></figure>  </p>
<p>多于多进程和多线程到底哪个更快，不妨先分析一下：  </p>
<p>首先，在这个小程序中，有很大的消耗在等待svn blame的返回结果，这里IO是瓶颈，那么多线程虽然有GIL，但是也可以实现并发。并且由于线程创建时的消耗小于多进程，所以在这一部分占得优势；  </p>
<p>其次，得到svn blame的结果之后，会完整的分析整个文件，进行一些字符串的操作。这里是CPU密集的，而多进程可以做到真正的并行，所以多进程在这一部分具有优势。  </p>
<p>再次，多线程的程序在svn blame阻塞时，会切换到其他线程执行。而多进程程序是每个核心各自执行，无序调度切换。这一部分，多进程占优。</p>
<p>那么最终的结果，就要取决于这几部分哪一部分所占的比重更大了。  </p>
<p>还是直接看测试结果吧。我去除了所有不必要的中间print语句和sleep语句，最终得到结果如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">多进程：</span><br><span class="line">real    <span class="number">0</span>m36<span class="number">.350</span>s</span><br><span class="line">user    <span class="number">0</span>m17<span class="number">.136</span>s</span><br><span class="line">sys     <span class="number">0</span>m8<span class="number">.172</span>s</span><br><span class="line">多线程：</span><br><span class="line">real    <span class="number">0</span>m44<span class="number">.212</span>s</span><br><span class="line">user    <span class="number">0</span>m17<span class="number">.824</span>s</span><br><span class="line">sys     <span class="number">0</span>m8<span class="number">.716</span>s</span><br><span class="line">单线程：</span><br><span class="line">real    <span class="number">4</span>m44<span class="number">.543</span>s</span><br><span class="line">user    <span class="number">0</span>m17<span class="number">.680</span>s</span><br><span class="line">sys     <span class="number">0</span>m8<span class="number">.492</span>s</span><br></pre></td></tr></table></figure>  </p>
<p>从realtime看，多进程要快于多线程，大约是单线程的八分之一时间。从CPU使用率上看（user+sys/real)，多进程版本的效率也更高一些。  </p>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><hr>
<p>好，经过统计，大约2年的时间，在项目主体中我的存量代码大概不到4w行。按照平均每年200个工作日算，平均一天100行代码。不算高产，但也还算状态健康。当然，平时的状态能这么均匀就太好了！实际情况是，一天撸3000行也是有的，一周只挤出100行也是有的……  </p>
<p>新年希望自己仍然能够保持这样的输出节奏，这样就有更多的时间，拓展自己的视野了~  </p>
<p>那写这篇文章呢，并不是要以代码量衡量一个程序员的产出（明显是不靠谱的方式）；而是想记录下，我通过做这件小事，理解了multiprocessing.dummy到底是个什么鬼，以及在出结果之前，如何理性的分析下多进程/多线程的优劣。希望对读者也有帮助。  </p>
<p>相关代码可以在GitHub上找到<a href="https://github.com/yubo1911/saber/tree/master/code-stats" target="_blank" rel="external">code-stats</a>。  </p>
<p>转载请注明出处： <a href="http://blog.guoyb.com/2017/01/09/stat-codes/">http://blog.guoyb.com/2017/01/09/stat-codes/</a>。  </p>
<p>欢迎使用微信扫描下方二维码，关注我的微信公众号TechTalking，技术·生活·思考：<br><img src="http://7d9lwm.com1.z0.glb.clouddn.com/newqr.jpg" alt="后端技术小黑屋"></p>

    
  </div>
  <footer>
    
      
  <div class="categories">
    <a class="categories-link" href="/categories/技术/">技术</a>
  </div>

      
  <div class="tags">
    <a class="tags-link" href="/tags/杂谈/">杂谈</a>
  </div>

      
    
    <div class="clearfix"></div>
  </footer>
</article>


<section id="comment">
  <h1 class="title">Comments</h1>
  <div class="ds-thread" data-thread-key="2017/01/09/stat-codes/" data-title="这些年，你写了多少行代码" data-url="http://blog.guoyb.com/2017/01/09/stat-codes/"></div>
</section>
</div>
  </div>
  
  <div id="sidebar" class="widgets-right">
  
<div class="widget category">
  <h3 class="title">categories</h3>
  <ul class="entry">
  
    <li><a href="/categories/书单/">书单</a><small>10</small></li>
  
    <li><a href="/categories/技术/">技术</a><small>88</small></li>
  
    <li><a href="/categories/杂谈/">杂谈</a><small>21</small></li>
  
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">recent_posts</h3>
  <ul class="entry">
    
      <li>
        <a href="/2018/10/27/uint-minus/">慎用unsigned int减法</a>
      </li>
    
      <li>
        <a href="/2018/09/22/interview/">面试造核弹，工作拧螺丝？</a>
      </li>
    
      <li>
        <a href="/2018/09/15/crontab-auto-kill/">crontab为何自动中断</a>
      </li>
    
      <li>
        <a href="/2018/09/08/protobuf-reflection/">ProtoBuf中的反射</a>
      </li>
    
      <li>
        <a href="/2018/08/25/antifragile/">《反脆弱》读后</a>
      </li>
    
  </ul>
</div>


  
<div class="widget tagcloud">
  <h3 class="title">tagcloud</h3>
  <div class="entry">
    <a href="/tags/C/" style="font-size: 10.91px;">C</a> <a href="/tags/C/" style="font-size: 18.18px;">C++</a> <a href="/tags/C-11/" style="font-size: 17.27px;">C++11</a> <a href="/tags/Decorator/" style="font-size: 10px;">Decorator</a> <a href="/tags/Git/" style="font-size: 10px;">Git</a> <a href="/tags/Linux/" style="font-size: 10.91px;">Linux</a> <a href="/tags/Makefile/" style="font-size: 10px;">Makefile</a> <a href="/tags/MySQL/" style="font-size: 10.91px;">MySQL</a> <a href="/tags/Python/" style="font-size: 19.09px;">Python</a> <a href="/tags/Scala/" style="font-size: 11.82px;">Scala</a> <a href="/tags/Spark/" style="font-size: 10.91px;">Spark</a> <a href="/tags/Ubuntu/" style="font-size: 10px;">Ubuntu</a> <a href="/tags/Unity3D/" style="font-size: 10px;">Unity3D</a> <a href="/tags/Vim/" style="font-size: 10.91px;">Vim</a> <a href="/tags/coroutine/" style="font-size: 10px;">coroutine</a> <a href="/tags/crontab/" style="font-size: 10px;">crontab</a> <a href="/tags/gcc/" style="font-size: 10px;">gcc</a> <a href="/tags/grpc/" style="font-size: 10.91px;">grpc</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/libuv/" style="font-size: 10.91px;">libuv</a> <a href="/tags/linker/" style="font-size: 10px;">linker</a> <a href="/tags/mutex/" style="font-size: 10px;">mutex</a> <a href="/tags/protobuf/" style="font-size: 12.73px;">protobuf</a> <a href="/tags/redis/" style="font-size: 12.73px;">redis</a> <a href="/tags/regex/" style="font-size: 12.73px;">regex</a> <a href="/tags/rwlock/" style="font-size: 10px;">rwlock</a> <a href="/tags/shell/" style="font-size: 10.91px;">shell</a> <a href="/tags/skynet/" style="font-size: 14.55px;">skynet</a> <a href="/tags/virtualenv/" style="font-size: 10px;">virtualenv</a> <a href="/tags/书单/" style="font-size: 16.36px;">书单</a> <a href="/tags/内存优化/" style="font-size: 10px;">内存优化</a> <a href="/tags/大数据/" style="font-size: 12.73px;">大数据</a> <a href="/tags/学习笔记/" style="font-size: 13.64px;">学习笔记</a> <a href="/tags/工具/" style="font-size: 10px;">工具</a> <a href="/tags/旅行/" style="font-size: 12.73px;">旅行</a> <a href="/tags/杂谈/" style="font-size: 20px;">杂谈</a> <a href="/tags/查证记录/" style="font-size: 12.73px;">查证记录</a> <a href="/tags/生活/" style="font-size: 14.55px;">生活</a> <a href="/tags/读书笔记/" style="font-size: 15.45px;">读书笔记</a>
  </div>
</div>


  
<div class="widget tag">
  <h3 class="title">友情链接</h3>
  <ul class="entry">
  
    
    <li><a href="http://www.linkedin.com/in/yubo-guo-739b0071" target="_blank">LinkedIn</a></li>
  
    
    <li><a href="http://www.tuicool.com/sites/2emeIjb" target="_blank">推酷站点</a></li>
  
  </ul>
</div>

</div>
  
  <footer id="footer"><div class="copyright">
  
  &copy; 2018 <a href="/">Yubo Guo</a>
  
</div>
<div class="theme-copyright">
  Theme by <a href="https://github.com/orderedlist" target="_blank">orderedlist</a>
   | 
  Redesign by <a href="http://blog.dafengning.com/" target="_blank">Chong Zi</a>
</div>
<div class="clearfix"></div></footer>
  <script src="//lib.sinaapp.com/js/jquery/1.8/jquery.min.js"></script>
<script src="/js/scale.fix.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>


<script type="text/javascript">
var duoshuoQuery = {short_name:"guoyb"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script>


<div id="rightfix" style="display:none;">

<a href="#comment" id="gocomm" class="fix_btn" title="提问/评论"><i><i></i></i></a>


<a href="javascript:void(0)" id="gotop" class="fix_btn" onclick="gotop();" title="回到顶部"><i></i></a>
<script>
  function gotop(){
    $('html,body').animate({
        scrollTop : '0px'
      }, 800);
  }
  $(function(){
    _rightfix = $('#rightfix');
    $(window).scroll(function(){
      $sollTop = document.documentElement.scrollTop + document.body.scrollTop;
      if($sollTop > 350){
        _rightfix.show();
      }else{
        _rightfix.hide();
      }
    });
  });
</script>

</div>


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
  (function($){
    $('.fancybox').fancybox();
  })(jQuery);
</script>

</body>
</html>